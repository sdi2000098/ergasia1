AM: 1115202000098
	
ΑΠΟΣΤΟΛΟΣ ΚΟΥΚΟΥΒΙΝΗΣ

Αναφορά Εργασία 1 Λειτουργικά Συστήματα Χειμερινό εξάμηνο 2023-2024

Το αρχέιο στο οποίο βρίσκεται η συνάρτηση main του project είναι το mvote.cpp.
Έπειτα υπάρχουν 2 σχεδόν ανεξάρτητα modules (ένα source file και ένα header ανά module)που 
υλοποιούν τις δομές γραμμικού κατακερματισμού και ανεστραμμένης λίστας (linked_hash και 
reverse_list αντίστοιχα). Ακόμη υπάρχει ένα module το οποίο παρέχει στον χρήστη (mvote) έναν
αφαιρετικό τρόπο αλληλεπίδρασης με τα δύο παραπάνω modules, δηλαδή ο χρήστης δεν ξέρει με ποιον 
τρόπο και μέσω ποιων δομών αποθηκεύονται και ανακτώνται τα δεδομένα, (voters module). Αφού ο χρήστης
εκτελέσει το πρόγραμμα και του εμφανιστεί το prompt μπορεί να επιλέξει μια από τις 9 λειτουργίες 
που περιγράφονται στην εκφώνηση καθώς και μια ακόμηξ πρόσθετη λειτουργία (prompt) που εμφανίζει 
ξανά το αρχικό prompt. Άμα ο χρήστης προσπαθήσει να εκτελέσει μια λειτουργία δίνοντας λάθος αριθμό
ορισμάτων ή το πλήθος των αρχικών ορισμάτων δεν αντιστοιχούν σε κάποια λειτουργία ή δεν υπάρχει 
αντίστοιχη λειτουργία με αυτά τα ορίσματα, το πρόγραμμα εμφανίζει μήνυμα λάθους και περιμένει νέα
λειτουργία. Παρόμοιο μήνυμα θα εμφανιστεί αν εισαχθεί μη αριθμητική ή αρνητική τιμή σε πεδίο που ζητά
θετικό ακέραιο, θεωρώ εδώ ότι το pin και το zip code ενός εκλέκτορα πρέπει να είναι θετικοί ακέραιοι 
αριθμοί. Η εντολή bv συνεχίζει την λειτουργία της όσο το input είναι θετικός ακέραιος, και σταματά όταν
δεν είναι. Η αναπαράσταση του εκλέκτορα γίνεται με την χρήση της κλάσης Voter, η δημιουργία των 
αντικειμένων γίνεται από την main δυναμικά μέσω της κλησης της CreateVoter με τα κατάλληλα ορίσμαατα.
Αφού η συνάρτηση κληθεί, δημιουργείται ένα στιγμιότυπο του Vote στον σωρό και ένας pointer στο στιγμιότυπο
αυτό, δίνεται σαν όρισμα στην Insert του πίνακα κατακερματισμού, έτσι δηλαδή, τα αντικείμενα του πίνακα 
είναι στην πραγματικότητα pointers σε στιγμιότυπα τύπου Voter που έχουν αποθηκευτεί στον σωρό. Με την σειρά
του, ο πίνακας κατακερματισμού αποτελείται από στιγμιότυπτα της κλάσης Bucket, όπου εκεί τελικά αποθηκεύονται
οι pointers στους Voters. Την ευθύνη για την καταστροφή των στιγμιοτύπων την έχει ο destructor της κλάσης που
αναπαριστά τα buckets του πίνακα  κατακερματισμού, που καλείται μέσω του destructor του πίνακα κατακερματισμού.
Η ανεστραμμένη λίστα αποθηκεύει pointers σε αντικείμενα τύπου Voter, αλλά δεν είναι υπέυθυνη για την αποδέσμευση
τους. Για την υλοποίηση της, έχω δημιουργήσεις δύο έξτρα structs, ένα που αντιστοιχεί σε κόμβου ΤΚ (ZipNode) και
ένα που αντιστοιχεί σε κόμβους αντικειμένων (ItemNode). Το κάθε ZipNode αποθηκεύει το πλήθος των αντικειμένων
που μπορούν να προσπελαστούν μέσω αυτού του ZipNode, δηλαδή το πλήθος των συμμετοχόντων που έχουν ψηφίσει από
το συγκεκριμένο ΤΚ. Ακόμη περιλαμβάνει έναν δείκτη στον πρώτο ItemNode και έναν δείκτη στον επόμενο ZipNode.
Το κάθε ItemNode αποθηκεύει έναν δείκτη σε κάποιο αντικείμενο και έναν δείκτη στον επόμενο ItemNode αν υπάρχει. 
Η λίστα των ZipNodes είναι αποθηκευμένη σε φθίνουσα σειρά σε σχέση με το πλήθος τον αντικειμένων της,
(ZipNode->NumberOfItems). Έτσι κάθε φορά που γίνεται εισαγωγή ενός Voter ελέγχουμε αν ήδη υπάρχει ZipNode 
με το συγκεκριμένο Zip του Voter, αν όχι τα πράγματα είναι απλά, εισάγουμε το καινούριο ZipNode στο τέλος της
λίστας, αφού θα έχει λιγότερα ή ισα αντικείμενα από τον κάθε ZipNode, δηλαδή 1. Αν όμως υπάρχει ήδη ZipNode, 
με αυτό το Zip, το ZipNode μπορεί να χρειαστεί να αλλάξει θέση, να μετατοπιστεί για την ακρίβεια πιο κοντά 
στην κεφαλή της λίστας, για να το πετύχουμε αυτό "διαγράφουμε" από την λίστα το ZipNode και το εισάγουμε ξανά
στην κατάλληλη θέση της λίστας. Έτσι η εισαγωγή στην λίστα έχει χρόνο χείριστης περίπτωσης O(N+N) = O(N), αφού
χρειάζεται να προσπελάσουμε όλα τα στοιχεία της λίστας δύο φορές, ενώ το Display γίνεται σε O(N), ήδη τακινομημένη.
Έχω προσθέσει ένα επιπλέον flag για την μέσω command line εκτέλεση του προγράμματος, το flag είναι το -m και 
μέσω αυτού ο χρήστης μπορεί να ορίσει το αρχικό μέγεθος του hash table. Τα flags μπορούν να εισαχθούν με 
οποιαδήποτε σεριά αρκεί να ακολουθούνται από την κατάλληλη τιμή. Υπάρχει αρχείο Makefile, το μόνο που χρειάζεται
είναι η εντολή make για την παραγωγή του εκτελέσιμου mvote. Για την εκτέλεση του mvote χρησιμοποιείται το
εργαλείο Valgrind. Ένας πιθανός τρόπος εκτέλεσης είναι με την εντολή :
valgrind -q --leak-check=full --track-origins=yes --show-leak-kinds=all --verbose  ./mvote -b 10 -f voters5000.csv -m 3
Επιτρέπεται επίσης η ξεχωριστή μεταγλώττιση, π.χ. μέσω της εντολής :
g++ -std=c++11 -Wall -g -c -o reverse_list.o reverse_list.cpp 
Παρέχεται επίσης και η δυνατότητα διαγραφής των .o files, μέσω της make clean